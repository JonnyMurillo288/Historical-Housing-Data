<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>County Income & Housing Affordability Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
    }
    #app {
      display: grid;
      grid-template-columns: var(--sidebar-width, 320px) 5px 1fr;
      grid-template-rows: auto 1fr;
      grid-template-areas:
        "header header header"
        "sidebar resizer map";
      height: 100%;
    }

    #sidebar {
      grid-area: sidebar;
      overflow-y: auto;
      border-right: 1px solid #ddd;
      padding: 0.75rem;
    }

    /* The draggable divider */
    #resizer {
      grid-area: resizer;
      cursor: col-resize;
      background: #ddd;
      width: 5px;
    }
    header {
      grid-area: header;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #bbb8b8;
      background: #bbb8b8;
    }
    header h1 {
      margin: 0;
      font-size: 1.2rem;
    }
    #map {
      grid-area: map;
      width: 100%;
      height: 100%;
    }
    .control-group {
      margin-bottom: 0.75rem;
    }
    .control-group label {
      font-weight: 600;
      display: block;
      margin-bottom: 0.25rem;
    }
    select {
      width: 100%;
      padding: 0.25rem 0.35rem;
      font-size: 0.9rem;
    }
    .mode-radio {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.25rem;
    }
    .legend {
      background: rgba(255, 255, 255, 0.95);
      padding: 8px 10px;
      border-radius: 8px;
      box-shadow: 0 0 6px rgba(0,0,0,0.25);
      font-size: 11px;
      line-height: 1.2;
    }
    .legend-title {
      font-weight: 600;
      margin-bottom: 4px;
    }
    .legend-row {
      display: flex;
      align-items: center;
      margin-bottom: 2px;
    }
    .legend-color-box {
      width: 18px;
      height: 10px;
      border: 1px solid #999;
      margin-right: 6px;
    }
    .hint {
      font-size: 0.8rem;
      color: #555;
      margin-top: 0.25rem;
    }
    #chart-container {
      margin-top: 0.5rem;
      padding-top: 0.5rem;
      border-top: 1px solid #ddd;
    }
    #chart-container canvas {
      width: 100%;
      max-height: 260px;
    }
    .chart-title {
      font-weight: 600;
      margin-bottom: 0.25rem;
      font-size: 0.9rem;
    }
  </style>
</head>

<body>
<div id="app">
  <header>
    <h1>Interactive County Map: Income & Housing Affordability</h1>
  </header>

  <aside id="sidebar">
    <div class="control-group">
      <label>View mode</label>
      <div class="mode-radio">
        <label><input type="radio" name="mode" value="single" checked /> Single year</label>
        <label><input type="radio" name="mode" value="compare" /> Compare two years</label>
      </div>
    </div>

    <div class="control-group" id="single-year-group">
      <label for="year-select">Year</label>
      <select id="year-select"></select>
    </div>

    <div class="control-group" id="compare-year-group" style="display:none;">
      <label>Compare years</label>
      <select id="year1-select"></select>
      <div style="height: 4px;"></div>
      <select id="year2-select"></select>
      <div class="hint">Year 2 must be greater than Year 1.</div>
    </div>

    <div class="control-group">
      <label for="metric-select">Metric</label>
      <select id="metric-select">
        <!-- filled dynamically -->
      </select>
      <div class="hint" id="metric-hint"></div>
    </div>

    <div class="control-group">
      <div class="hint">
        Hover over a county on the map for details.
      </div>
    </div>

    <!-- Compare-mode county chart controls -->
    <div class="control-group" id="county-chart-group" style="display:none;">
      <label for="county-select">County time series (HAI & RAI)</label>
      <select id="county-select"></select>
      <div class="hint">Select a county to see HAI and RAI by year.</div>
      <div id="chart-container">
        <div class="chart-title" id="chart-title">HAI & RAI over time</div>
        <canvas id="county-chart"></canvas>
      </div>
    </div>
  </aside>

  <div id="resizer"></div>
  <div id="map"></div>
</div>

<!-- Leaflet JS -->
<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>

<!-- Chart.js for line chart -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

<script>
// ----------------------------
// Global state
// ----------------------------
let countiesGeojson = null;       // raw GeoJSON
let metrics = [];                 // array of {county_fips_full, year, ...}
let years = [];                   // sorted unique years
let metricsByKey = {};            // key: fips_year -> row
let countyList = [];              // { fips, name }

let map, geoLayer, legendControl;
let countyChart = null;

// same ramp as your Python (_compute_color_scale)
const COLOR_RAMP = [
  [33, 102, 172, 255],
  [146, 197, 222, 255],
  [255, 255, 255, 255],
  [254, 229, 217, 255],
  [252, 187, 161, 255],
  [252, 146, 114, 255],
  [251, 106, 74, 255],
  [239, 59, 44, 255],
  [202, 0, 32, 255]
];

// Custom diverging ramp for RAI % change (7 colors)
const RAI_CHANGE_RAMP = [
  [222, 45, 38, 255],     // deep red
  [252, 187, 161, 255],   // light red
  [255, 255, 255, 255],   // midpoint (0%)
  [222, 235, 247, 255],   // very light blue
  [198, 219, 239, 255],   // light blue
  [146, 197, 222, 255],   // medium blue
  [33, 102, 172, 255]     // deep blue
];

// Fixed breaks for RAI % change (7 bins)
const RAI_CHANGE_BREAKS = [
  -Infinity,   // deep red
  -25,         // light red
   0,          // white
  25,          // very light blue
  50,          // light blue
 100,          // medium blue
 150,          // deep blue
  Infinity
];

const METRIC_OPTIONS = [
  { value: "HAI",  label: "HAI – Housing Affordability Index" },
  { value: "RAI",  label: "RAI – Rent Affordability Index" },
  { value: "median_household_income", label: "Median Household Income" },
  { value: "median_gross_rent",       label: "Median Gross Rent" },
  { value: "median_home_value",       label: "Median Home Value" },
  { value: "median_monthly_rent_income", label: "Median Monthly Income (Monthly)" },
];

function fmtCurrency(x) {
  if (x == null || isNaN(x)) return "N/A";
  return "$" + x.toLocaleString(undefined, {maximumFractionDigits: 0});
}
function fmtRatio(x) {
  if (x == null || isNaN(x)) return "N/A";
  return x.toLocaleString(undefined, {maximumFractionDigits: 2});
}
function fmtPct(x) {
  if (x == null || isNaN(x)) return "N/A";
  return x.toLocaleString(undefined, {maximumFractionDigits: 1}) + "%";
}

// ----------------------------
// Color scale computation
// ----------------------------
function computeColorScale(values, compareMode) {
  const metric = getMetric();
  const vals = values.filter(v => v != null && !isNaN(v));

  if (vals.length === 0) {
    return { breaks: [], colors: COLOR_RAMP };
  }

  // SPECIAL CASE: RAI change
  if (compareMode && metric === "RAI") {
    return {
      breaks: RAI_CHANGE_BREAKS,
      colors: RAI_CHANGE_RAMP
    };
  }

  // General compare mode (HAI and others)
  if (compareMode) {
    return {
      breaks: [-Infinity, 0, 10, 20, 40, 60, 80, 100, 150, Infinity],
      colors: COLOR_RAMP
    };
  }

  // Single-year mode (quantile ramp)
  vals.sort((a, b) => a - b);
  const n = COLOR_RAMP.length;
  const breaks = [];

  for (let i = 0; i <= n; i++) {
    const idx = Math.floor((i / n) * (vals.length - 1));
    breaks.push(vals[idx]);
  }

  return { breaks, colors: COLOR_RAMP };
}

function valueToColor(v, scale, reverse, treatAsPctChange) {
  if (v == null || isNaN(v) || !scale.breaks.length) {
    return "rgba(200,200,200,0.5)";
  }
  const {breaks, colors} = scale;
  let idx = 0;
  for (let i = 0; i < breaks.length - 1; i++) {
    if (v >= breaks[i] && v < breaks[i + 1]) {
      idx = i;
      break;
    }
  }
  if (idx >= colors.length) idx = colors.length - 1;

  let colorArr = colors[idx];
  if (reverse) {
    const rIdx = (colors.length - 1) - idx;
    colorArr = colors[rIdx];
  }
  const [r, g, b, a] = colorArr;
  return `rgba(${r},${g},${b},${a/255})`;
}

// ----------------------------
// Map + layers
// ----------------------------
function initMap() {
  map = L.map("map").setView([38.5, -98.0], 4);

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 12,
    attribution: "&copy; OpenStreetMap contributors"
  }).addTo(map);

  geoLayer = L.geoJSON(countiesGeojson, {
    style: feature => styleForFeature(feature),
    onEachFeature: (feature, layer) => {
      layer.on("mouseover", ev => onFeatureHover(feature, layer, ev));
      layer.on("mouseout", ev => layer.closePopup());
    }
  }).addTo(map);

  map.fitBounds(geoLayer.getBounds());

  // legend
  legendControl = L.control({position: "bottomright"});
  legendControl.onAdd = function() {
    const div = L.DomUtil.create("div", "legend");
    return div;
  };
  legendControl.addTo(map);

  updateLegend();
}

function styleForFeature(feature) {
  const fips = feature.properties.county_fips_full;
  const mode = getMode();
  const metric = getMetric();
  const {year, year1, year2} = getYears();
  let value = null;

  if (mode === "single") {
    const key = `${fips}_${year}`;
    const row = metricsByKey[key];
    if (row) value = row[metric];
  } else {
    const key1 = `${fips}_${year1}`;
    const key2 = `${fips}_${year2}`;
    const r1 = metricsByKey[key1];
    const r2 = metricsByKey[key2];
    if (r1 && r2) {
      const v1 = r1[metric];
      const v2 = r2[metric];
      if (v1 != null && v2 != null && !isNaN(v1) && v1 !== 0) {
        value = ((v2 - v1) / v1) * 100;
      }
    }
  }

  const scale = getCurrentColorScale();
  // RAI uses its own diverging ramp → do NOT reverse
  //const reverse = (metric === "RAI");
  const reverse = false;
  const fillColor = valueToColor(value, scale, reverse, false);

  return {
    color: "#555",
    weight: 0.5,
    fillColor,
    fillOpacity: 0.8
  };
}

function onFeatureHover(feature, layer, ev) {
  const fips = feature.properties.county_fips_full;
  const mode = getMode();
  const metric = getMetric();
  const {year, year1, year2} = getYears();
  const countyName =
    feature.properties.county_name_lad ||
    feature.properties.county_name ||
    "Unknown County";

  let html = `<b>${countyName}</b><br/>`;
  const keyBase = mode === "single" ? `${fips}_${year}` : null;

  if (mode === "single") {
    const row = metricsByKey[keyBase];
    if (!row) {
      html += "No data.";
    } else {
      if (metric === "HAI") {
        html += `HAI: ${fmtRatio(row.HAI)}<br/>`;
        html += `Median Income: ${fmtCurrency(row.median_household_income)}<br/>`;
        html += `Median Home Value: ${fmtCurrency(row.median_home_value)}`;
      } else if (metric === "RAI") {
        html += `RAI: ${fmtRatio(row.RAI)}<br/>`;
        html += `Monthly Income: ${fmtCurrency(row.median_monthly_rent_income)}<br/>`;
        html += `Median Rent: ${fmtCurrency(row.median_gross_rent)}`;
      } else if (metric === "median_household_income") {
        html += `Median Household Income: ${fmtCurrency(row.median_household_income)}<br/>`;
        html += `Median Home Value: ${fmtCurrency(row.median_home_value)}`;
      } else if (metric === "median_gross_rent") {
        html += `Median Rent: ${fmtCurrency(row.median_gross_rent)}<br/>`;
        html += `Monthly Income: ${fmtCurrency(row.median_monthly_rent_income)}`;
      } else if (metric === "median_home_value") {
        html += `Median Home Value: ${fmtCurrency(row.median_home_value)}<br/>`;
        html += `Median Household Income: ${fmtCurrency(row.median_household_income)}`;
      } else if (metric === "median_monthly_rent_income") {
        html += `Monthly Income: ${fmtCurrency(row.median_monthly_rent_income)}<br/>`;
        html += `Median Rent: ${fmtCurrency(row.median_gross_rent)}`;
      }
    }
  } else {
    const k1 = `${fips}_${year1}`;
    const k2 = `${fips}_${year2}`;
    const r1 = metricsByKey[k1];
    const r2 = metricsByKey[k2];

    if (!(r1 && r2)) {
      html += "No data for one or both years.";
    } else {
      const v1 = r1[metric];
      const v2 = r2[metric];
      const change = (v1 != null && v2 != null && v1 !== 0)
        ? ((v2 - v1) / v1) * 100
        : null;

      if (metric === "HAI") {
        html += `HAI Change: ${fmtPct(change)}<br/>`;
        html += `HAI ${year1}: ${fmtRatio(r1.HAI)}<br/>`;
        html += `HAI ${year2}: ${fmtRatio(r2.HAI)}<br/>`;
        html += `Income ${year1}: ${fmtCurrency(r1.median_household_income)}<br/>`;
        html += `Income ${year2}: ${fmtCurrency(r2.median_household_income)}<br/>`;
        html += `Home Value ${year1}: ${fmtCurrency(r1.median_home_value)}<br/>`;
        html += `Home Value ${year2}: ${fmtCurrency(r2.median_home_value)}`;
      } else if (metric === "RAI") {
        html += `RAI Change: ${fmtPct(change)}<br/>`;
        html += `RAI ${year1}: ${fmtRatio(r1.RAI)}<br/>`;
        html += `RAI ${year2}: ${fmtRatio(r2.RAI)}<br/>`;
        html += `Monthly Income ${year1}: ${fmtCurrency(r1.median_monthly_rent_income)}<br/>`;
        html += `Monthly Income ${year2}: ${fmtCurrency(r2.median_monthly_rent_income)}<br/>`;
        html += `Rent ${year1}: ${fmtCurrency(r1.median_gross_rent)}<br/>`;
        html += `Rent ${year2}: ${fmtCurrency(r2.median_gross_rent)}`;
      } else {
        html += `${metric} Change: ${fmtPct(change)}<br/>`;
        html += `${metric} ${year1}: ${fmtCurrency(v1)}<br/>`;
        html += `${metric} ${year2}: ${fmtCurrency(v2)}`;
      }
    }
  }

  layer.bindPopup(html, {closeButton: false}).openPopup(ev.latlng);
}

// ----------------------------
// Color scale + legend cache
// ----------------------------
let cachedScale = null;
let cachedScaleKey = "";

function getCurrentColorScale() {
  const mode = getMode();
  const metric = getMetric();
  const {year, year1, year2} = getYears();
  const key = `${mode}_${metric}_${year}_${year1}_${year2}`;

  if (cachedScale && cachedScaleKey === key) {
    return cachedScale;
  }

  const values = [];
  if (mode === "single") {
    metrics.forEach(row => {
      if (row.year === year && row[metric] != null && !isNaN(row[metric])) {
        values.push(row[metric]);
      }
    });
  } else {
    metrics.forEach(row => {
      if (row.year === year1 || row.year === year2) {
        if (row.year === year2 && row[metric] != null && !isNaN(row[metric])) {
          values.push(row[metric]);
        }
      }
    });
  }

  const scale = computeColorScale(values, mode === "compare");
  cachedScale = scale;
  cachedScaleKey = key;
  return scale;
}

function getMetric() {
  const sel = document.getElementById("metric-select");
  return sel.value;
}
function getMode() {
  const radios = document.querySelectorAll("input[name='mode']");
  for (const r of radios) if (r.checked) return r.value;
  return "single";
}
function getYears() {
  const yearSel = document.getElementById("year-select");
  const year1Sel = document.getElementById("year1-select");
  const year2Sel = document.getElementById("year2-select");

  const year = parseInt(yearSel.value || years[0], 10);
  const year1 = parseInt(year1Sel.value || years[0], 10);
  const year2 = parseInt(year2Sel.value || years[years.length - 1], 10);

  return {year, year1, year2};
}

// ----------------------------
// Legend
// ----------------------------
function updateLegend() {
  const container = legendControl.getContainer();
  if (!container) return;

  container.innerHTML = ""; // clear

  const metric = getMetric();
  const mode = getMode();
  const scale = getCurrentColorScale();
  const {breaks, colors} = scale;

  const titleDiv = document.createElement("div");
  titleDiv.className = "legend-title";
  if (mode === "single") {
    titleDiv.textContent = metric;
  } else {
    titleDiv.textContent = `${metric} – % change`;
  }
  container.appendChild(titleDiv);

  if (!breaks.length) {
    container.appendChild(document.createTextNode("No data"));
    return;
  }

  const labels = [];
  for (let i = 0; i < breaks.length - 1; i++) {
    const low = breaks[i];
    const high = breaks[i + 1];
    if (!isFinite(low) && isFinite(high)) {
      labels.push(`≤ ${high.toFixed(1)}`);
    } else if (isFinite(low) && !isFinite(high)) {
      labels.push(`≥ ${low.toFixed(1)}`);
    } else {
      labels.push(`${low.toFixed(1)} – ${high.toFixed(1)}`);
    }
  }

  let cArr = colors;
  // RAI uses custom diverging scale → do NOT reverse
  if (metric !== "RAI") {
    cArr = [...colors];
  }

  for (let i = 0; i < cArr.length; i++) {
    const rowDiv = document.createElement("div");
    rowDiv.className = "legend-row";

    const box = document.createElement("div");
    box.className = "legend-color-box";
    const [r, g, b, a] = cArr[i];
    box.style.background = `rgba(${r},${g},${b},${a/255})`;

    const labelSpan = document.createElement("span");
    labelSpan.textContent = labels[i] || "";

    rowDiv.appendChild(box);
    rowDiv.appendChild(labelSpan);
    container.appendChild(rowDiv);
  }
}

// ----------------------------
// Chart helpers
// ----------------------------
function buildCountyList() {
  const seen = new Map();
  metrics.forEach(row => {
    const fips = String(row.county_fips_full);
    if (!seen.has(fips)) {
      const name = row.county_name || fips;
      seen.set(fips, name);
    }
  });
  countyList = Array.from(seen.entries())
    .map(([fips, name]) => ({fips, name}))
    .sort((a, b) => a.name.localeCompare(b.name));
}

function initCountySelect() {
  const countySelect = document.getElementById("county-select");
  countySelect.innerHTML = "";
  countyList.forEach(c => {
    const opt = document.createElement("option");
    opt.value = c.fips;
    opt.textContent = c.name;
    countySelect.appendChild(opt);
  });
  if (countyList.length > 0) {
    countySelect.value = countyList[0].fips;
  }
  countySelect.addEventListener("change", () => {
    updateCountyChart();
  });
}

function updateCountyChart() {
  const mode = getMode();
  const group = document.getElementById("county-chart-group");
  if (mode !== "compare") {
    group.style.display = "none";
    if (countyChart) {
      countyChart.destroy();
      countyChart = null;
    }
    return;
  }
  group.style.display = "";

  const countySelect = document.getElementById("county-select");
  const fips = countySelect.value;
  if (!fips) return;

  const labels = [];
  const haiData = [];
  const raiData = [];

  years.forEach(y => {
    const key = `${fips}_${y}`;
    const row = metricsByKey[key];
    labels.push(y);
    if (row) {
      haiData.push(row.HAI != null ? Number(row.HAI) : null);
      raiData.push(row.RAI != null ? Number(row.RAI) : null);
    } else {
      haiData.push(null);
      raiData.push(null);
    }
  });

  const ctx = document.getElementById("county-chart").getContext("2d");
  if (countyChart) {
    countyChart.destroy();
  }

  const countyName = (countyList.find(c => c.fips === fips) || {}).name || fips;
  const chartTitleEl = document.getElementById("chart-title");
  chartTitleEl.textContent = `HAI & RAI over time – ${countyName}`;

  countyChart = new Chart(ctx, {
    type: "line",
    data: {
      labels,
      datasets: [
        {
          label: "HAI",
          data: haiData,
          borderColor: "rgba(239, 59, 44, 1)",
          backgroundColor: "rgba(239, 59, 44, 0.15)",
          tension: 0.2,
          spanGaps: true,
          yAxisID: "y"
        },
        {
          label: "RAI",
          data: raiData,
          borderColor: "rgba(33, 102, 172, 1)",
          backgroundColor: "rgba(33, 102, 172, 0.15)",
          tension: 0.2,
          spanGaps: true,
          yAxisID: "y1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: {
        mode: "index",
        intersect: false
      },
      scales: {
        x: {
          title: { display: true, text: "Year" },
          ticks: { autoSkip: true, maxTicksLimit: 8 }
        },
        y: {
          type: "linear",
          position: "left",
          title: { display: true, text: "HAI" }
        },
        y1: {
          type: "linear",
          position: "right",
          grid: { drawOnChartArea: false },
          title: { display: true, text: "RAI" }
        }
      },
      plugins: {
        legend: { position: "top" },
        tooltip: {
          callbacks: {
            label: function(ctx) {
              const val = ctx.parsed.y;
              if (val == null || isNaN(val)) return `${ctx.dataset.label}: N/A`;
              return `${ctx.dataset.label}: ${val.toFixed(2)}`;
            }
          }
        }
      }
    }
  });
}

// ----------------------------
// UI wiring
// ----------------------------
function initControls() {
  const yearSel = document.getElementById("year-select");
  const year1Sel = document.getElementById("year1-select");
  const year2Sel = document.getElementById("year2-select");
  const metricSel = document.getElementById("metric-select");
  const singleGroup = document.getElementById("single-year-group");
  const compareGroup = document.getElementById("compare-year-group");
  const metricHint = document.getElementById("metric-hint");
  const countyChartGroup = document.getElementById("county-chart-group");

  // populate years
  years.forEach(y => {
    const opt = document.createElement("option");
    opt.value = y;
    opt.textContent = y;
    yearSel.appendChild(opt.cloneNode(true));
    year1Sel.appendChild(opt.cloneNode(true));
    year2Sel.appendChild(opt.cloneNode(true));
  });
  yearSel.value = years[years.length - 1];
  year2Sel.value = years[years.length - 1];
  year1Sel.value = years[0];

  // populate metrics
  METRIC_OPTIONS.forEach(m => {
    const opt = document.createElement("option");
    opt.value = m.value;
    opt.textContent = m.label;
    metricSel.appendChild(opt);
  });
  metricSel.value = "HAI";
  metricHint.textContent = "HAI = median home value / median household income. RAI = monthly income / monthly rent.";

  // build county list + init select
  buildCountyList();
  initCountySelect();

  // mode change
  document.querySelectorAll("input[name='mode']").forEach(radio => {
    radio.addEventListener("change", () => {
      const mode = getMode();
      if (mode === "single") {
        singleGroup.style.display = "";
        compareGroup.style.display = "none";
        countyChartGroup.style.display = "none";
      } else {
        singleGroup.style.display = "none";
        compareGroup.style.display = "";
        countyChartGroup.style.display = "";
        updateCountyChart();
      }
      cachedScale = null;
      geoLayer.setStyle(styleForFeature);
      updateLegend();
    });
  });

  // year changes
  [yearSel, year1Sel, year2Sel].forEach(sel => {
    sel.addEventListener("change", () => {
      const {year1, year2} = getYears();
      if (getMode() === "compare" && year2 <= year1) {
        const idx1 = years.indexOf(year1);
        const idx2 = Math.min(years.length - 1, idx1 + 1);
        year2Sel.value = years[idx2];
      }
      cachedScale = null;
      geoLayer.setStyle(styleForFeature);
      updateLegend();
      if (getMode() === "compare") {
        updateCountyChart();
      }
    });
  });

  // metric change
  metricSel.addEventListener("change", () => {
    const metric = getMetric();
    if (metric === "HAI" || metric === "RAI") {
      metricHint.textContent = "HAI = median home value / median household income. RAI = monthly income / monthly rent.";
    } else {
      metricHint.textContent = "";
    }
    cachedScale = null;
    geoLayer.setStyle(styleForFeature);
    updateLegend();
  });
}

// ----------------------------
// Data loading
// ----------------------------
async function loadData() {
  const [geoResp, metricsResp] = await Promise.all([
    fetch("data/counties.geojson"),
    fetch("data/metrics.json")
  ]);
  countiesGeojson = await geoResp.json();
  metrics = await metricsResp.json();

  metricsByKey = {};
  const yearSet = new Set();
  metrics.forEach(row => {
    const fips = String(row.county_fips_full);
    const year = Number(row.year);
    yearSet.add(year);
    metricsByKey[`${fips}_${year}`] = row;
  });
  years = Array.from(yearSet).sort((a, b) => a - b);
}

// ----------------------------
// Sidebar Resizer
// ----------------------------

const sidebar = document.getElementById("sidebar");
const resizer = document.getElementById("resizer");
let isDragging = false;

resizer.addEventListener("mousedown", function(e) {
  isDragging = true;
  document.body.style.cursor = "col-resize";
});

window.addEventListener("mousemove", function(e) {
  if (!isDragging) return;

  const newWidth = e.clientX;  // distance from left edge
  if (newWidth > 200 && newWidth < window.innerWidth - 200) {
    document.documentElement.style.setProperty(
      "--sidebar-width",
      `${newWidth}px`
    );
  }
});

window.addEventListener("mouseup", function() {
  isDragging = false;
  document.body.style.cursor = "default";
});

// ----------------------------
// Boot
// ----------------------------
(async function boot() {
  try {
    await loadData();
    initMap();
    initControls();
  } catch (err) {
    console.error("Failed to load data or initialize map:", err);
    alert("Failed to load map data. See console for details.");
  }
})();
</script>
</body>
</html>
